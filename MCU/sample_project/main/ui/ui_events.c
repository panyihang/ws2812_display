// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.0
// LVGL version: 8.3.6
// Project name: led_test_light

#include "ui.h"

#include "ble.h"
#include "4g.h"
#include "ir.h"
#include "asr.h"

#include "config.h"
uint8_t first_setup = 0;
dispdata_t current_data;
bool floce_save_large_array = false;

void screen_setup()
{
	if (first_setup == 0)
	{
		first_setup++;
		// 初始化 NVS 和 config 系统
		esp_err_t err = config_init();
		if (err != ESP_OK)
		{
			ESP_LOGE("MAIN", "Config init failed");
			return;
		}

		config_read(&current_data);

		// 检查是否为首次初始化
		if (!current_data.first_config)
		{
			ESP_LOGI("MAIN", "First time config");

			// 创建并初始化默认的 dispdata
			dispdata_t default_data;
			config_initialize_defaults(&default_data);

			// 保存默认的 config
			config_write(&default_data);
			config_write_large_arrays(&default_data);
			_ui_screen_change(&ui_Screen2, LV_SCR_LOAD_ANIM_MOVE_LEFT, 1000, 800, &ui_Screen2_screen_init);
		}
		else
		{
			ESP_LOGI("MAIN", "Loading existing config");

			config_read_large_arrays(&current_data);
			ESP_LOGI("MAIN", "BLE enabled: %d", current_data.ble_enable);
			_ui_screen_change(&ui_Screen3, LV_SCR_LOAD_ANIM_MOVE_LEFT, 1000, 5000, &ui_Screen3_screen_init);
		}
	}
}
static lv_obj_t *msg_label;
static lv_timer_t *hide_timer;
static char display_text[50]; // 全局变量，用于存储要显示的文本
// 隐藏label的回调函数
static void hide_label_cb(lv_timer_t *timer)
{
	lv_obj_add_flag(msg_label, LV_OBJ_FLAG_HIDDEN); // 隐藏label
	lv_timer_pause(hide_timer);						// 暂停定时器
}

// 显示label的回调函数
static void show_label_cb(lv_timer_t *timer)
{
	// 设置label文本
	lv_label_set_text(msg_label, display_text);

	// 如果label是隐藏状态，取消隐藏并启动定时器
	if (lv_obj_has_flag(msg_label, LV_OBJ_FLAG_HIDDEN))
	{
		lv_obj_clear_flag(msg_label, LV_OBJ_FLAG_HIDDEN);
	}

	// 重置定时器计数以延长显示时间
	lv_timer_reset(hide_timer);
	lv_timer_resume(hide_timer);
}

// 初始化label
void init_msg_label()
{
	msg_label = lv_label_create(ui_Screen3);

	// 设置字体为16号字体
	lv_obj_set_style_text_font(msg_label, &lv_font_montserrat_14, 0);

	// 设置文字颜色为白色
	lv_obj_set_style_text_color(msg_label, lv_color_hex(0xFFFFFF), 0);

	// 默认隐藏label
	lv_obj_add_flag(msg_label, LV_OBJ_FLAG_HIDDEN);

	// 居中label
	lv_obj_align(msg_label, LV_ALIGN_CENTER, 0, 0);
	// 设置Label背景颜色为黑色
	lv_obj_set_style_bg_color(msg_label, lv_color_hex(0x000000), 0);

	// 设置背景不透明
	lv_obj_set_style_bg_opa(msg_label, LV_OPA_COVER, 0);

	// 创建一个定时器来控制隐藏，默认暂停
	hide_timer = lv_timer_create(hide_label_cb, 2000, NULL);
	lv_timer_pause(hide_timer);
}

// disp_msg函数实现
void disp_msg(const char *msg, uint8_t source)
{
	// 根据source设置显示文本
	if (source == 0x01)
	{
		snprintf(display_text, sizeof(display_text), "ble: %s", msg);
	}
	else if (source == 0x02)
	{
		snprintf(display_text, sizeof(display_text), "ir: %s", msg);
	}
	else if (source == 0x04)
	{
		snprintf(display_text, sizeof(display_text), "ASR: %s", msg);
	}
	else
	{
		snprintf(display_text, sizeof(display_text), "unknown: %s", msg);
	}

	// 启动定时器来执行显示逻辑
	lv_timer_t *show_timer = lv_timer_create(show_label_cb, 0, NULL);
	lv_timer_set_repeat_count(show_timer, 1); // 设置为只执行一次的定时器
}

void change_large_text_screen1(char *text)
{
	lv_label_set_text(ui_Label5, text);
}

void change_large_text_color_screen1(int color)
{
	lv_obj_set_style_text_color(ui_Label5, lv_color_hex(color), LV_PART_MAIN | LV_STATE_DEFAULT);
}

static void update_disp_timer_cb(lv_timer_t *timer)
{
	// 从定时器的用户数据中获取当前数据
	dispdata_t *current_data = (dispdata_t *)timer->user_data;
	if (current_data->hiden_enable)
	{
		lv_obj_add_flag(ui_Label5, LV_OBJ_FLAG_HIDDEN);
	}
	else
	{
		lv_obj_clear_flag(ui_Label5, LV_OBJ_FLAG_HIDDEN);
	}

	lv_obj_set_style_anim_speed(ui_Label5, current_data->speed[current_data->disp_chat_id], 0);
	lv_label_set_text(ui_Label5, current_data->chat_data[current_data->disp_chat_id]);
	lv_obj_set_style_text_color(ui_Label5, lv_color_hex(current_data->color[current_data->disp_chat_id]), LV_PART_MAIN | LV_STATE_DEFAULT);
}

void start_disp_update_timer(dispdata_t *current_data)
{
	// 创建定时器任务，间隔时间根据需求调整
	lv_timer_t *timer = lv_timer_create(update_disp_timer_cb, 100, current_data);
	// 立即调用一次，执行 `update_disp_main()` 中的逻辑
	lv_timer_ready(timer);
}

void update_disp_main()
{
	// 现在你可以调用 `start_disp_update_timer()` 来更新显示
	start_disp_update_timer(&current_data);
}

void config_screen_load()
{
	// Your code here
}

void main_screen_load()
{
	if (current_data.ble_enable)
	{
		ESP_LOGI("MAIN", "BLE enabled: %d", current_data.ble_enable);
		ble_start();
	}
	if (current_data.g4_enable)
	{
		ESP_LOGI("MAIN", "4G enabled: %d", current_data.g4_enable);
		start_cat1();
	}

	ir_init();
	ASR_init();

	init_msg_label();
	update_disp_main();
}

// Helper function to log actions
void log_action(uint8_t source, const char *action)
{
	if (current_data.log_index < sizeof(current_data.log))
	{
		current_data.log[current_data.log_index++] = source;
		// Additional logging details can be stored in a separate array if needed
		ESP_LOGI("MAIN", "Logged action: %s by source: %u", action, source);
		config_write(&current_data);
		if (current_data.log_index % 10 == 0 || floce_save_large_array)
		{
			config_write_large_arrays(&current_data);
			floce_save_large_array = false;
		}
	}
	else
	{
		current_data.log_index = 0;
		config_write(&current_data);
		ESP_LOGI("MAIN", "Log is full!");
	}
}

// Get and set functions for disp_chat_id
uint8_t get_disp_chat_id()
{
	return current_data.disp_chat_id;
}

void set_disp_chat_id(uint8_t chat_id, uint8_t source)
{
	current_data.disp_chat_id = chat_id;
	log_action(source, "Set disp_chat_id");
}

// Get and set functions for disp_chat_id
bool get_hiden_enable()
{
	return current_data.hiden_enable;
}

void set_hiden_enable(bool enable, uint8_t source)
{
	current_data.hiden_enable = enable;
	log_action(source, "change hiden_enable");
	update_disp_main();
}

// Get and set functions for chat_data[index]
void get_chat_data(uint8_t index, char *data)
{
	if (index < 50)
	{
		strcpy(data, current_data.chat_data[index]);
	}
}

void set_chat_data(uint8_t index, const char *data, uint8_t source)
{
	if (index < 50)
	{
		strncpy(current_data.chat_data[index], data, 100);
		floce_save_large_array = true;
		log_action(source, "Set chat_data");
		update_disp_main();
	}
}

// Get and set functions for color[index]
uint32_t get_color(uint8_t index)
{
	if (index < 50)
	{
		return current_data.color[index];
	}
	return 0xFFFFFF; // Default color
}

void set_color(uint8_t index, uint32_t color_value, uint8_t source)
{
	if (index < 50)
	{
		current_data.color[index] = color_value;
		floce_save_large_array = true;
		log_action(source, "Set color");
		update_disp_main();
	}
}

// Get and set functions for speed[index]
uint16_t get_speed(uint8_t index)
{
	if (index < 50)
	{
		return current_data.speed[index];
	}
	return 0; // Default speed
}

void set_speed(uint8_t index, uint16_t speed_value, uint8_t source)
{
	if (index < 50)
	{
		current_data.speed[index] = speed_value;
		log_action(source, "Set speed");
		update_disp_main();
	}
}

// Get and set functions for g4_enable
bool get_g4_enable()
{
	return current_data.g4_enable;
}

void set_g4_enable(bool enable, uint8_t source)
{
	current_data.g4_enable = enable;
	log_action(source, "Set g4_enable");
}

// Get and set functions for IR_enable
bool get_IR_enable()
{
	return current_data.IR_enable;
}

void set_IR_enable(bool enable, uint8_t source)
{
	current_data.IR_enable = enable;
	log_action(source, "Set IR_enable");
}

// Log read and write functions
void write_log(uint8_t data, uint8_t source)
{
	if (current_data.log_index < sizeof(current_data.log))
	{
		current_data.log[current_data.log_index++] = data;
		log_action(source, "Write log");
	}
	else
	{
		ESP_LOGI("MAIN", "Log is full!");
	}
}

uint8_t read_log(uint16_t index)
{
	if (index < current_data.log_index)
	{
		return current_data.log[index];
	}
	return 0; // Default return if index is out of bounds
}
